{"ast":null,"code":"import { createContext, useRef, useState, useLayoutEffect, createElement, useContext, useEffect, useMemo, useCallback, Children, isValidElement, Fragment } from 'react';\nimport { createMemoryHistory, Action, parsePath } from 'history';\n\nfunction _extends() {\n  _extends = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n\n    return target;\n  };\n\n  return _extends.apply(this, arguments);\n}\n\nvar readOnly = process.env.NODE_ENV !== \"production\" ? function (obj) {\n  return Object.freeze(obj);\n} : function (obj) {\n  return obj;\n};\n\nfunction invariant(cond, message) {\n  if (!cond) throw new Error(message);\n}\n\nfunction warning(cond, message) {\n  if (!cond) {\n    // eslint-disable-next-line no-console\n    if (typeof console !== \"undefined\") console.warn(message);\n\n    try {\n      // Welcome to debugging React Router!\n      //\n      // This error is thrown as a convenience so you can more easily\n      // find the source for a warning that appears in the console by\n      // enabling \"pause on exceptions\" in your JavaScript debugger.\n      throw new Error(message); // eslint-disable-next-line no-empty\n    } catch (e) {}\n  }\n}\n\nvar alreadyWarned = {};\n\nfunction warningOnce(key, cond, message) {\n  if (!cond && !alreadyWarned[key]) {\n    alreadyWarned[key] = true;\n    process.env.NODE_ENV !== \"production\" ? warning(false, message) : void 0;\n  }\n}\n\nvar NavigatorContext = /*#__PURE__*/createContext(null);\nvar LocationContext = /*#__PURE__*/createContext({\n  static: false\n});\n\nif (process.env.NODE_ENV !== \"production\") {\n  LocationContext.displayName = \"Location\";\n}\n\nvar RouteContext = /*#__PURE__*/createContext({\n  outlet: null,\n  params: readOnly({}),\n  pathname: \"\",\n  basename: \"\",\n  route: null\n});\n\nif (process.env.NODE_ENV !== \"production\") {\n  RouteContext.displayName = \"Route\";\n}\n/**\n * A <Router> that stores all entries in memory.\n *\n * @see https://reactrouter.com/api/MemoryRouter\n */\n\n\nfunction MemoryRouter(_ref) {\n  var children = _ref.children,\n      initialEntries = _ref.initialEntries,\n      initialIndex = _ref.initialIndex;\n  var historyRef = useRef();\n\n  if (historyRef.current == null) {\n    historyRef.current = createMemoryHistory({\n      initialEntries: initialEntries,\n      initialIndex: initialIndex\n    });\n  }\n\n  var history = historyRef.current;\n\n  var _React$useState = useState({\n    action: history.action,\n    location: history.location\n  }),\n      state = _React$useState[0],\n      setState = _React$useState[1];\n\n  useLayoutEffect(function () {\n    return history.listen(setState);\n  }, [history]);\n  return /*#__PURE__*/createElement(Router, {\n    children: children,\n    action: state.action,\n    location: state.location,\n    navigator: history\n  });\n}\n/**\n * Changes the current location.\n *\n * Note: This API is mostly useful in React.Component subclasses that are not\n * able to use hooks. In functional components, we recommend you use the\n * `useNavigate` hook instead.\n *\n * @see https://reactrouter.com/api/Navigate\n */\n\n\nfunction Navigate(_ref2) {\n  var to = _ref2.to,\n      replace = _ref2.replace,\n      state = _ref2.state;\n  !useInRouterContext() ? process.env.NODE_ENV !== \"production\" ? invariant(false, // TODO: This error is probably because they somehow have 2 versions of\n  // the router loaded. We can help them understand how to avoid that.\n  \"<Navigate> may be used only in the context of a <Router> component.\") : invariant(false) : void 0;\n  process.env.NODE_ENV !== \"production\" ? warning(!useContext(LocationContext).static, \"<Navigate> must not be used on the initial render in a <StaticRouter>. \" + \"This is a no-op, but you should modify your code so the <Navigate> is \" + \"only ever rendered in response to some user interaction or state change.\") : void 0;\n  var navigate = useNavigate();\n  useEffect(function () {\n    navigate(to, {\n      replace: replace,\n      state: state\n    });\n  });\n  return null;\n}\n/**\n * Renders the child route's element, if there is one.\n *\n * @see https://reactrouter.com/api/Outlet\n */\n\n\nfunction Outlet(_props) {\n  return useOutlet();\n}\n/**\n * Declares an element that should be rendered at a certain URL path.\n *\n * @see https://reactrouter.com/api/Route\n */\n\n\nfunction Route(_ref3) {\n  var _ref3$element = _ref3.element,\n      element = _ref3$element === void 0 ? /*#__PURE__*/createElement(Outlet, null) : _ref3$element;\n  return element;\n}\n/**\n * Provides location context for the rest of the app.\n *\n * Note: You usually won't render a <Router> directly. Instead, you'll render a\n * router that is more specific to your environment such as a <BrowserRouter>\n * in web browsers or a <StaticRouter> for server rendering.\n *\n * @see https://reactrouter.com/api/Router\n */\n\n\nfunction Router(_ref4) {\n  var _ref4$children = _ref4.children,\n      children = _ref4$children === void 0 ? null : _ref4$children,\n      _ref4$action = _ref4.action,\n      action = _ref4$action === void 0 ? Action.Pop : _ref4$action,\n      location = _ref4.location,\n      navigator = _ref4.navigator,\n      _ref4$static = _ref4.static,\n      staticProp = _ref4$static === void 0 ? false : _ref4$static;\n  !!useInRouterContext() ? process.env.NODE_ENV !== \"production\" ? invariant(false, \"You cannot render a <Router> inside another <Router>.\" + \" You never need more than one.\") : invariant(false) : void 0;\n  return /*#__PURE__*/createElement(NavigatorContext.Provider, {\n    value: navigator\n  }, /*#__PURE__*/createElement(LocationContext.Provider, {\n    children: children,\n    value: {\n      action: action,\n      location: location,\n      static: staticProp\n    }\n  }));\n}\n/**\n * A container for a nested tree of <Route> elements that renders the branch\n * that best matches the current location.\n *\n * @see https://reactrouter.com/api/Routes\n */\n\n\nfunction Routes(_ref5) {\n  var _ref5$basename = _ref5.basename,\n      basename = _ref5$basename === void 0 ? \"\" : _ref5$basename,\n      children = _ref5.children;\n  var routes = createRoutesFromChildren(children);\n  var location = useLocation();\n  return useRoutes_(routes, location, basename);\n} ///////////////////////////////////////////////////////////////////////////////\n// HOOKS\n///////////////////////////////////////////////////////////////////////////////\n\n/**\n * Blocks all navigation attempts. This is useful for preventing the page from\n * changing until some condition is met, like saving form data.\n *\n * @see https://reactrouter.com/api/useBlocker\n */\n\n\nfunction useBlocker(blocker, when) {\n  if (when === void 0) {\n    when = true;\n  }\n\n  !useInRouterContext() ? process.env.NODE_ENV !== \"production\" ? invariant(false, // TODO: This error is probably because they somehow have 2 versions of the\n  // router loaded. We can help them understand how to avoid that.\n  \"useBlocker() may be used only in the context of a <Router> component.\") : invariant(false) : void 0;\n  var navigator = useContext(NavigatorContext);\n  useEffect(function () {\n    if (!when) return;\n    var unblock = navigator.block(function (tx) {\n      var autoUnblockingTx = _extends({}, tx, {\n        retry: function retry() {\n          // Automatically unblock the transition so it can play all the way\n          // through before retrying it. TODO: Figure out how to re-enable\n          // this block if the transition is cancelled for some reason.\n          unblock();\n          tx.retry();\n        }\n      });\n\n      blocker(autoUnblockingTx);\n    });\n    return unblock;\n  }, [navigator, blocker, when]);\n}\n/**\n * Returns the full href for the given \"to\" value. This is useful for building\n * custom links that are also accessible and preserve right-click behavior.\n *\n * @see https://reactrouter.com/api/useHref\n */\n\n\nfunction useHref(to) {\n  !useInRouterContext() ? process.env.NODE_ENV !== \"production\" ? invariant(false, // TODO: This error is probably because they somehow have 2 versions of the\n  // router loaded. We can help them understand how to avoid that.\n  \"useHref() may be used only in the context of a <Router> component.\") : invariant(false) : void 0;\n  var navigator = useContext(NavigatorContext);\n  var path = useResolvedPath(to);\n  return navigator.createHref(path);\n}\n/**\n * Returns true if this component is a descendant of a <Router>.\n *\n * @see https://reactrouter.com/api/useInRouterContext\n */\n\n\nfunction useInRouterContext() {\n  return useContext(LocationContext).location != null;\n}\n/**\n * Returns the current location object, which represents the current URL in web\n * browsers.\n *\n * Note: If you're using this it may mean you're doing some of your own\n * \"routing\" in your app, and we'd like to know what your use case is. We may\n * be able to provide something higher-level to better suit your needs.\n *\n * @see https://reactrouter.com/api/useLocation\n */\n\n\nfunction useLocation() {\n  !useInRouterContext() ? process.env.NODE_ENV !== \"production\" ? invariant(false, // TODO: This error is probably because they somehow have 2 versions of the\n  // router loaded. We can help them understand how to avoid that.\n  \"useLocation() may be used only in the context of a <Router> component.\") : invariant(false) : void 0;\n  return useContext(LocationContext).location;\n}\n/**\n * Returns true if the URL for the given \"to\" value matches the current URL.\n * This is useful for components that need to know \"active\" state, e.g.\n * <NavLink>.\n *\n * @see https://reactrouter.com/api/useMatch\n */\n\n\nfunction useMatch(pattern) {\n  !useInRouterContext() ? process.env.NODE_ENV !== \"production\" ? invariant(false, // TODO: This error is probably because they somehow have 2 versions of the\n  // router loaded. We can help them understand how to avoid that.\n  \"useMatch() may be used only in the context of a <Router> component.\") : invariant(false) : void 0;\n  var location = useLocation();\n  return matchPath(pattern, location.pathname);\n}\n/**\n * Returns an imperative method for changing the location. Used by <Link>s, but\n * may also be used by other elements to change the location.\n *\n * @see https://reactrouter.com/api/useNavigate\n */\n\n\nfunction useNavigate() {\n  !useInRouterContext() ? process.env.NODE_ENV !== \"production\" ? invariant(false, // TODO: This error is probably because they somehow have 2 versions of the\n  // router loaded. We can help them understand how to avoid that.\n  \"useNavigate() may be used only in the context of a <Router> component.\") : invariant(false) : void 0;\n  var navigator = useContext(NavigatorContext);\n\n  var _React$useContext = useContext(RouteContext),\n      pathname = _React$useContext.pathname,\n      basename = _React$useContext.basename;\n\n  var activeRef = useRef(false);\n  useEffect(function () {\n    activeRef.current = true;\n  });\n  var navigate = useCallback(function (to, options) {\n    if (options === void 0) {\n      options = {};\n    }\n\n    if (activeRef.current) {\n      if (typeof to === \"number\") {\n        navigator.go(to);\n      } else {\n        var path = resolvePath(to, pathname, basename);\n        (!!options.replace ? navigator.replace : navigator.push)(path, options.state);\n      }\n    } else {\n      process.env.NODE_ENV !== \"production\" ? warning(false, \"You should call navigate() in a useEffect, not when \" + \"your component is first rendered.\") : void 0;\n    }\n  }, [basename, navigator, pathname]);\n  return navigate;\n}\n/**\n * Returns the element for the child route at this level of the route\n * hierarchy. Used internally by <Outlet> to render child routes.\n *\n * @see https://reactrouter.com/api/useOutlet\n */\n\n\nfunction useOutlet() {\n  return useContext(RouteContext).outlet;\n}\n/**\n * Returns an object of key/value pairs of the dynamic params from the current\n * URL that were matched by the route path.\n *\n * @see https://reactrouter.com/api/useParams\n */\n\n\nfunction useParams() {\n  return useContext(RouteContext).params;\n}\n/**\n * Resolves the pathname of the given `to` value against the current location.\n *\n * @see https://reactrouter.com/api/useResolvedPath\n */\n\n\nfunction useResolvedPath(to) {\n  var _React$useContext2 = useContext(RouteContext),\n      pathname = _React$useContext2.pathname,\n      basename = _React$useContext2.basename;\n\n  return useMemo(function () {\n    return resolvePath(to, pathname, basename);\n  }, [to, pathname, basename]);\n}\n/**\n * Returns the element of the route that matched the current location, prepared\n * with the correct context to render the remainder of the route tree. Route\n * elements in the tree must render an <Outlet> to render their child route's\n * element.\n *\n * @see https://reactrouter.com/api/useRoutes\n */\n\n\nfunction useRoutes(partialRoutes, basename) {\n  if (basename === void 0) {\n    basename = \"\";\n  }\n\n  !useInRouterContext() ? process.env.NODE_ENV !== \"production\" ? invariant(false, // TODO: This error is probably because they somehow have 2 versions of the\n  // router loaded. We can help them understand how to avoid that.\n  \"useRoutes() may be used only in the context of a <Router> component.\") : invariant(false) : void 0;\n  var location = useLocation();\n  var routes = useMemo(function () {\n    return createRoutesFromArray(partialRoutes);\n  }, [partialRoutes]);\n  return useRoutes_(routes, location, basename);\n}\n\nfunction useRoutes_(routes, location, basename) {\n  if (basename === void 0) {\n    basename = \"\";\n  }\n\n  var _React$useContext3 = useContext(RouteContext),\n      parentRoute = _React$useContext3.route,\n      parentPathname = _React$useContext3.pathname,\n      parentParams = _React$useContext3.params;\n\n  if (process.env.NODE_ENV !== \"production\") {\n    // You won't get a warning about 2 different <Routes> under a <Route>\n    // without a trailing *, but this is a best-effort warning anyway since we\n    // cannot even give the warning unless they land at the parent route.\n    var parentPath = parentRoute && parentRoute.path;\n    warningOnce(parentPathname, !parentRoute || parentRoute.path.endsWith(\"*\"), \"You rendered descendant <Routes> (or called `useRoutes`) at \" + (\"\\\"\" + parentPathname + \"\\\" (under <Route path=\\\"\" + parentPath + \"\\\">) but the \") + \"parent route path has no trailing \\\"*\\\". This means if you navigate \" + \"deeper, the parent won't match anymore and therefore the child \" + \"routes will never render.\\n\\n\" + (\"Please change the parent <Route path=\\\"\" + parentPath + \"\\\"> to <Route \") + (\"path=\\\"\" + parentPath + \"/*\\\">.\"));\n  }\n\n  var basenameForMatching = basename ? joinPaths([parentPathname, basename]) : parentPathname;\n  var matches = useMemo(function () {\n    return matchRoutes(routes, location, basenameForMatching);\n  }, [location, routes, basenameForMatching]);\n\n  if (!matches) {\n    // TODO: Warn about nothing matching, suggest using a catch-all route.\n    return null;\n  } // Otherwise render an element.\n\n\n  var allParams = {};\n  var element = matches.reduceRight(function (outlet, _ref6) {\n    var params = _ref6.params,\n        pathname = _ref6.pathname,\n        route = _ref6.route;\n    allParams = _extends({}, allParams, params);\n    return /*#__PURE__*/createElement(RouteContext.Provider, {\n      children: route.element,\n      value: {\n        outlet: outlet,\n        params: readOnly(_extends({}, parentParams, allParams)),\n        pathname: joinPaths([basenameForMatching, pathname]),\n        basename: basename,\n        route: route\n      }\n    });\n  }, null);\n  return element;\n} ///////////////////////////////////////////////////////////////////////////////\n// UTILS\n///////////////////////////////////////////////////////////////////////////////\n\n/**\n * Creates a route config from an array of JavaScript objects. Used internally\n * by `useRoutes` to normalize the route config.\n *\n * @see https://reactrouter.com/api/createRoutesFromArray\n */\n\n\nfunction createRoutesFromArray(array) {\n  return array.map(function (partialRoute) {\n    var route = {\n      path: partialRoute.path || \"/\",\n      caseSensitive: partialRoute.caseSensitive === true,\n      element: partialRoute.element || /*#__PURE__*/createElement(Outlet, null)\n    };\n\n    if (partialRoute.children) {\n      route.children = createRoutesFromArray(partialRoute.children);\n    }\n\n    return route;\n  });\n}\n/**\n * Creates a route config from a React \"children\" object, which is usually\n * either a `<Route>` element or an array of them. Used internally by\n * `<Routes>` to create a route config from its children.\n *\n * @see https://reactrouter.com/api/createRoutesFromChildren\n */\n\n\nfunction createRoutesFromChildren(children) {\n  var routes = [];\n  Children.forEach(children, function (element) {\n    if (! /*#__PURE__*/isValidElement(element)) {\n      // Ignore non-elements. This allows people to more easily inline\n      // conditionals in their route config.\n      return;\n    }\n\n    if (element.type === Fragment) {\n      // Transparently support React.Fragment and its children.\n      routes.push.apply(routes, createRoutesFromChildren(element.props.children));\n      return;\n    }\n\n    var route = {\n      path: element.props.path || \"/\",\n      caseSensitive: element.props.caseSensitive === true,\n      // Default behavior is to just render the element that was given. This\n      // permits people to use any element they prefer, not just <Route> (though\n      // all our official examples and docs use <Route> for clarity).\n      element: element\n    };\n\n    if (element.props.children) {\n      var childRoutes = createRoutesFromChildren(element.props.children);\n\n      if (childRoutes.length) {\n        route.children = childRoutes;\n      }\n    }\n\n    routes.push(route);\n  });\n  return routes;\n}\n/**\n * Returns a path with params interpolated.\n *\n * @see https://reactrouter.com/api/generatePath\n */\n\n\nfunction generatePath(path, params) {\n  if (params === void 0) {\n    params = {};\n  }\n\n  return path.replace(/:(\\w+)/g, function (_, key) {\n    !(params[key] != null) ? process.env.NODE_ENV !== \"production\" ? invariant(false, \"Missing \\\":\" + key + \"\\\" param\") : invariant(false) : void 0;\n    return params[key];\n  }).replace(/\\/*\\*$/, function (_) {\n    return params[\"*\"] == null ? \"\" : params[\"*\"].replace(/^\\/*/, \"/\");\n  });\n}\n/**\n * Matches the given routes to a location and returns the match data.\n *\n * @see https://reactrouter.com/api/matchRoutes\n */\n\n\nfunction matchRoutes(routes, location, basename) {\n  if (basename === void 0) {\n    basename = \"\";\n  }\n\n  if (typeof location === \"string\") {\n    location = parsePath(location);\n  }\n\n  var pathname = location.pathname || \"/\";\n\n  if (basename) {\n    var base = basename.replace(/^\\/*/, \"/\").replace(/\\/+$/, \"\");\n\n    if (pathname.startsWith(base)) {\n      pathname = pathname === base ? \"/\" : pathname.slice(base.length);\n    } else {\n      // Pathname does not start with the basename, no match.\n      return null;\n    }\n  }\n\n  var branches = flattenRoutes(routes);\n  rankRouteBranches(branches);\n  var matches = null;\n\n  for (var i = 0; matches == null && i < branches.length; ++i) {\n    // TODO: Match on search, state too?\n    matches = matchRouteBranch(branches[i], pathname);\n  }\n\n  return matches;\n}\n\nfunction flattenRoutes(routes, branches, parentPath, parentRoutes, parentIndexes) {\n  if (branches === void 0) {\n    branches = [];\n  }\n\n  if (parentPath === void 0) {\n    parentPath = \"\";\n  }\n\n  if (parentRoutes === void 0) {\n    parentRoutes = [];\n  }\n\n  if (parentIndexes === void 0) {\n    parentIndexes = [];\n  }\n\n  routes.forEach(function (route, index) {\n    route = _extends({}, route, {\n      path: route.path || \"/\",\n      caseSensitive: !!route.caseSensitive,\n      element: route.element\n    });\n    var path = joinPaths([parentPath, route.path]);\n    var routes = parentRoutes.concat(route);\n    var indexes = parentIndexes.concat(index); // Add the children before adding this route to the array so we traverse the\n    // route tree depth-first and child routes appear before their parents in\n    // the \"flattened\" version.\n\n    if (route.children) {\n      flattenRoutes(route.children, branches, path, routes, indexes);\n    }\n\n    branches.push([path, routes, indexes]);\n  });\n  return branches;\n}\n\nfunction rankRouteBranches(branches) {\n  var pathScores = branches.reduce(function (memo, _ref7) {\n    var path = _ref7[0];\n    memo[path] = computeScore(path);\n    return memo;\n  }, {}); // Sorting is stable in modern browsers, but we still support IE 11, so we\n  // need this little helper.\n\n  stableSort(branches, function (a, b) {\n    var aPath = a[0],\n        aIndexes = a[2];\n    var aScore = pathScores[aPath];\n    var bPath = b[0],\n        bIndexes = b[2];\n    var bScore = pathScores[bPath];\n    return aScore !== bScore ? bScore - aScore // Higher score first\n    : compareIndexes(aIndexes, bIndexes);\n  });\n}\n\nvar paramRe = /^:\\w+$/;\nvar dynamicSegmentValue = 2;\nvar emptySegmentValue = 1;\nvar staticSegmentValue = 10;\nvar splatPenalty = -2;\n\nvar isSplat = function isSplat(s) {\n  return s === \"*\";\n};\n\nfunction computeScore(path) {\n  var segments = path.split(\"/\");\n  var initialScore = segments.length;\n\n  if (segments.some(isSplat)) {\n    initialScore += splatPenalty;\n  }\n\n  return segments.filter(function (s) {\n    return !isSplat(s);\n  }).reduce(function (score, segment) {\n    return score + (paramRe.test(segment) ? dynamicSegmentValue : segment === \"\" ? emptySegmentValue : staticSegmentValue);\n  }, initialScore);\n}\n\nfunction compareIndexes(a, b) {\n  var siblings = a.length === b.length && a.slice(0, -1).every(function (n, i) {\n    return n === b[i];\n  });\n  return siblings ? // If two routes are siblings, we should try to match the earlier sibling\n  // first. This allows people to have fine-grained control over the matching\n  // behavior by simply putting routes with identical paths in the order they\n  // want them tried.\n  a[a.length - 1] - b[b.length - 1] : // Otherwise, it doesn't really make sense to rank non-siblings by index,\n  // so they sort equally.\n  0;\n}\n\nfunction stableSort(array, compareItems) {\n  // This copy lets us get the original index of an item so we can preserve the\n  // original ordering in the case that they sort equally.\n  var copy = array.slice(0);\n  array.sort(function (a, b) {\n    return compareItems(a, b) || copy.indexOf(a) - copy.indexOf(b);\n  });\n}\n\nfunction matchRouteBranch(branch, pathname) {\n  var routes = branch[1];\n  var matchedPathname = \"/\";\n  var matchedParams = {};\n  var matches = [];\n\n  for (var i = 0; i < routes.length; ++i) {\n    var route = routes[i];\n    var remainingPathname = matchedPathname === \"/\" ? pathname : pathname.slice(matchedPathname.length) || \"/\";\n    var routeMatch = matchPath({\n      path: route.path,\n      caseSensitive: route.caseSensitive,\n      end: i === routes.length - 1\n    }, remainingPathname);\n    if (!routeMatch) return null;\n    matchedPathname = joinPaths([matchedPathname, routeMatch.pathname]);\n    matchedParams = _extends({}, matchedParams, routeMatch.params);\n    matches.push({\n      route: route,\n      pathname: matchedPathname,\n      params: readOnly(matchedParams)\n    });\n  }\n\n  return matches;\n}\n/**\n * Performs pattern matching on a URL pathname and returns information about\n * the match.\n *\n * @see https://reactrouter.com/api/matchPath\n */\n\n\nfunction matchPath(pattern, pathname) {\n  if (typeof pattern === \"string\") {\n    pattern = {\n      path: pattern\n    };\n  }\n\n  var _pattern = pattern,\n      path = _pattern.path,\n      _pattern$caseSensitiv = _pattern.caseSensitive,\n      caseSensitive = _pattern$caseSensitiv === void 0 ? false : _pattern$caseSensitiv,\n      _pattern$end = _pattern.end,\n      end = _pattern$end === void 0 ? true : _pattern$end;\n\n  var _compilePath = compilePath(path, caseSensitive, end),\n      matcher = _compilePath[0],\n      paramNames = _compilePath[1];\n\n  var match = pathname.match(matcher);\n  if (!match) return null;\n  var matchedPathname = match[1];\n  var values = match.slice(2);\n  var params = paramNames.reduce(function (memo, paramName, index) {\n    memo[paramName] = safelyDecodeURIComponent(values[index] || \"\", paramName);\n    return memo;\n  }, {});\n  return {\n    path: path,\n    pathname: matchedPathname,\n    params: params\n  };\n}\n\nfunction compilePath(path, caseSensitive, end) {\n  var keys = [];\n  var source = \"^(\" + path.replace(/^\\/*/, \"/\") // Make sure it has a leading /\n  .replace(/\\/?\\*?$/, \"\") // Ignore trailing / and /*, we'll handle it below\n  .replace(/[\\\\.*+^$?{}|()[\\]]/g, \"\\\\$&\") // Escape special regex chars\n  .replace(/:(\\w+)/g, function (_, key) {\n    keys.push(key);\n    return \"([^\\\\/]+)\";\n  }) + \")\";\n\n  if (path.endsWith(\"*\")) {\n    if (path.endsWith(\"/*\")) {\n      source += \"(?:\\\\/(.+)|\\\\/?)\"; // Don't include the / in params['*']\n    } else {\n      source += \"(.*)\";\n    }\n\n    keys.push(\"*\");\n  } else if (end) {\n    source += \"\\\\/?\";\n  }\n\n  if (end) source += \"$\";\n  var flags = caseSensitive ? undefined : \"i\";\n  var matcher = new RegExp(source, flags);\n  return [matcher, keys];\n}\n\nfunction safelyDecodeURIComponent(value, paramName) {\n  try {\n    return decodeURIComponent(value);\n  } catch (error) {\n    process.env.NODE_ENV !== \"production\" ? warning(false, \"The value for the URL param \\\"\" + paramName + \"\\\" will not be decoded because\" + (\" the string \\\"\" + value + \"\\\" is a malformed URL segment. This is probably\") + (\" due to a bad percent encoding (\" + error + \").\")) : void 0;\n    return value;\n  }\n}\n/**\n * Returns a resolved path object relative to the given pathname.\n *\n * @see https://reactrouter.com/api/resolvePath\n */\n\n\nfunction resolvePath(to, fromPathname, basename) {\n  if (fromPathname === void 0) {\n    fromPathname = \"/\";\n  }\n\n  if (basename === void 0) {\n    basename = \"\";\n  }\n\n  var _ref8 = typeof to === \"string\" ? parsePath(to) : to,\n      toPathname = _ref8.pathname,\n      _ref8$search = _ref8.search,\n      search = _ref8$search === void 0 ? \"\" : _ref8$search,\n      _ref8$hash = _ref8.hash,\n      hash = _ref8$hash === void 0 ? \"\" : _ref8$hash;\n\n  var pathname = toPathname ? resolvePathname(toPathname, toPathname.startsWith(\"/\") ? basename ? normalizeSlashes(\"/\" + basename) : \"/\" : fromPathname) : fromPathname;\n  return {\n    pathname: pathname,\n    search: normalizeSearch(search),\n    hash: normalizeHash(hash)\n  };\n}\n\nvar trimTrailingSlashes = function trimTrailingSlashes(path) {\n  return path.replace(/\\/+$/, \"\");\n};\n\nvar normalizeSlashes = function normalizeSlashes(path) {\n  return path.replace(/\\/\\/+/g, \"/\");\n};\n\nvar joinPaths = function joinPaths(paths) {\n  return normalizeSlashes(paths.join(\"/\"));\n};\n\nvar splitPath = function splitPath(path) {\n  return normalizeSlashes(path).split(\"/\");\n};\n\nvar normalizeSearch = function normalizeSearch(search) {\n  return !search || search === \"?\" ? \"\" : search.startsWith(\"?\") ? search : \"?\" + search;\n};\n\nvar normalizeHash = function normalizeHash(hash) {\n  return !hash || hash === \"#\" ? \"\" : hash.startsWith(\"#\") ? hash : \"#\" + hash;\n};\n\nfunction resolvePathname(toPathname, fromPathname) {\n  var segments = splitPath(trimTrailingSlashes(fromPathname));\n  var relativeSegments = splitPath(toPathname);\n  relativeSegments.forEach(function (segment) {\n    if (segment === \"..\") {\n      // Keep the root \"\" segment so the pathname starts at /\n      if (segments.length > 1) segments.pop();\n    } else if (segment !== \".\") {\n      segments.push(segment);\n    }\n  });\n  return segments.length > 1 ? joinPaths(segments) : \"/\";\n} ///////////////////////////////////////////////////////////////////////////////\n\n\nexport { MemoryRouter, Navigate, Outlet, Route, Router, Routes, LocationContext as UNSAFE_LocationContext, NavigatorContext as UNSAFE_NavigatorContext, RouteContext as UNSAFE_RouteContext, createRoutesFromArray, createRoutesFromChildren, generatePath, matchPath, matchRoutes, resolvePath, useBlocker, useHref, useInRouterContext, useLocation, useMatch, useNavigate, useOutlet, useParams, useResolvedPath, useRoutes };","map":{"version":3,"sources":["../../packages/react-router/index.tsx"],"names":["React.useContext"],"mappings":"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","sourcesContent":["import { createContext, useRef, useState, useLayoutEffect, createElement, useContext, useEffect, useMemo, useCallback, Children, isValidElement, Fragment } from 'react';\nimport { createMemoryHistory, Action, parsePath } from 'history';\n\nfunction _extends() {\n  _extends = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n\n    return target;\n  };\n\n  return _extends.apply(this, arguments);\n}\n\nvar readOnly = process.env.NODE_ENV !== \"production\" ? function (obj) {\n  return Object.freeze(obj);\n} : function (obj) {\n  return obj;\n};\n\nfunction invariant(cond, message) {\n  if (!cond) throw new Error(message);\n}\n\nfunction warning(cond, message) {\n  if (!cond) {\n    // eslint-disable-next-line no-console\n    if (typeof console !== \"undefined\") console.warn(message);\n\n    try {\n      // Welcome to debugging React Router!\n      //\n      // This error is thrown as a convenience so you can more easily\n      // find the source for a warning that appears in the console by\n      // enabling \"pause on exceptions\" in your JavaScript debugger.\n      throw new Error(message); // eslint-disable-next-line no-empty\n    } catch (e) {}\n  }\n}\n\nvar alreadyWarned = {};\n\nfunction warningOnce(key, cond, message) {\n  if (!cond && !alreadyWarned[key]) {\n    alreadyWarned[key] = true;\n    process.env.NODE_ENV !== \"production\" ? warning(false, message) : void 0;\n  }\n}\n\nvar NavigatorContext = /*#__PURE__*/createContext(null);\nvar LocationContext = /*#__PURE__*/createContext({\n  static: false\n});\n\nif (process.env.NODE_ENV !== \"production\") {\n  LocationContext.displayName = \"Location\";\n}\n\nvar RouteContext = /*#__PURE__*/createContext({\n  outlet: null,\n  params: readOnly({}),\n  pathname: \"\",\n  basename: \"\",\n  route: null\n});\n\nif (process.env.NODE_ENV !== \"production\") {\n  RouteContext.displayName = \"Route\";\n}\n/**\n * A <Router> that stores all entries in memory.\n *\n * @see https://reactrouter.com/api/MemoryRouter\n */\n\n\nfunction MemoryRouter(_ref) {\n  var children = _ref.children,\n      initialEntries = _ref.initialEntries,\n      initialIndex = _ref.initialIndex;\n  var historyRef = useRef();\n\n  if (historyRef.current == null) {\n    historyRef.current = createMemoryHistory({\n      initialEntries: initialEntries,\n      initialIndex: initialIndex\n    });\n  }\n\n  var history = historyRef.current;\n\n  var _React$useState = useState({\n    action: history.action,\n    location: history.location\n  }),\n      state = _React$useState[0],\n      setState = _React$useState[1];\n\n  useLayoutEffect(function () {\n    return history.listen(setState);\n  }, [history]);\n  return /*#__PURE__*/createElement(Router, {\n    children: children,\n    action: state.action,\n    location: state.location,\n    navigator: history\n  });\n}\n/**\n * Changes the current location.\n *\n * Note: This API is mostly useful in React.Component subclasses that are not\n * able to use hooks. In functional components, we recommend you use the\n * `useNavigate` hook instead.\n *\n * @see https://reactrouter.com/api/Navigate\n */\n\nfunction Navigate(_ref2) {\n  var to = _ref2.to,\n      replace = _ref2.replace,\n      state = _ref2.state;\n  !useInRouterContext() ? process.env.NODE_ENV !== \"production\" ? invariant(false, // TODO: This error is probably because they somehow have 2 versions of\n  // the router loaded. We can help them understand how to avoid that.\n  \"<Navigate> may be used only in the context of a <Router> component.\") : invariant(false) : void 0;\n  process.env.NODE_ENV !== \"production\" ? warning(!useContext(LocationContext).static, \"<Navigate> must not be used on the initial render in a <StaticRouter>. \" + \"This is a no-op, but you should modify your code so the <Navigate> is \" + \"only ever rendered in response to some user interaction or state change.\") : void 0;\n  var navigate = useNavigate();\n  useEffect(function () {\n    navigate(to, {\n      replace: replace,\n      state: state\n    });\n  });\n  return null;\n}\n/**\n * Renders the child route's element, if there is one.\n *\n * @see https://reactrouter.com/api/Outlet\n */\n\nfunction Outlet(_props) {\n  return useOutlet();\n}\n/**\n * Declares an element that should be rendered at a certain URL path.\n *\n * @see https://reactrouter.com/api/Route\n */\n\nfunction Route(_ref3) {\n  var _ref3$element = _ref3.element,\n      element = _ref3$element === void 0 ? /*#__PURE__*/createElement(Outlet, null) : _ref3$element;\n  return element;\n}\n/**\n * Provides location context for the rest of the app.\n *\n * Note: You usually won't render a <Router> directly. Instead, you'll render a\n * router that is more specific to your environment such as a <BrowserRouter>\n * in web browsers or a <StaticRouter> for server rendering.\n *\n * @see https://reactrouter.com/api/Router\n */\n\nfunction Router(_ref4) {\n  var _ref4$children = _ref4.children,\n      children = _ref4$children === void 0 ? null : _ref4$children,\n      _ref4$action = _ref4.action,\n      action = _ref4$action === void 0 ? Action.Pop : _ref4$action,\n      location = _ref4.location,\n      navigator = _ref4.navigator,\n      _ref4$static = _ref4.static,\n      staticProp = _ref4$static === void 0 ? false : _ref4$static;\n  !!useInRouterContext() ? process.env.NODE_ENV !== \"production\" ? invariant(false, \"You cannot render a <Router> inside another <Router>.\" + \" You never need more than one.\") : invariant(false) : void 0;\n  return /*#__PURE__*/createElement(NavigatorContext.Provider, {\n    value: navigator\n  }, /*#__PURE__*/createElement(LocationContext.Provider, {\n    children: children,\n    value: {\n      action: action,\n      location: location,\n      static: staticProp\n    }\n  }));\n}\n/**\n * A container for a nested tree of <Route> elements that renders the branch\n * that best matches the current location.\n *\n * @see https://reactrouter.com/api/Routes\n */\n\nfunction Routes(_ref5) {\n  var _ref5$basename = _ref5.basename,\n      basename = _ref5$basename === void 0 ? \"\" : _ref5$basename,\n      children = _ref5.children;\n  var routes = createRoutesFromChildren(children);\n  var location = useLocation();\n  return useRoutes_(routes, location, basename);\n} ///////////////////////////////////////////////////////////////////////////////\n// HOOKS\n///////////////////////////////////////////////////////////////////////////////\n\n/**\n * Blocks all navigation attempts. This is useful for preventing the page from\n * changing until some condition is met, like saving form data.\n *\n * @see https://reactrouter.com/api/useBlocker\n */\n\nfunction useBlocker(blocker, when) {\n  if (when === void 0) {\n    when = true;\n  }\n\n  !useInRouterContext() ? process.env.NODE_ENV !== \"production\" ? invariant(false, // TODO: This error is probably because they somehow have 2 versions of the\n  // router loaded. We can help them understand how to avoid that.\n  \"useBlocker() may be used only in the context of a <Router> component.\") : invariant(false) : void 0;\n  var navigator = useContext(NavigatorContext);\n  useEffect(function () {\n    if (!when) return;\n    var unblock = navigator.block(function (tx) {\n      var autoUnblockingTx = _extends({}, tx, {\n        retry: function retry() {\n          // Automatically unblock the transition so it can play all the way\n          // through before retrying it. TODO: Figure out how to re-enable\n          // this block if the transition is cancelled for some reason.\n          unblock();\n          tx.retry();\n        }\n      });\n\n      blocker(autoUnblockingTx);\n    });\n    return unblock;\n  }, [navigator, blocker, when]);\n}\n/**\n * Returns the full href for the given \"to\" value. This is useful for building\n * custom links that are also accessible and preserve right-click behavior.\n *\n * @see https://reactrouter.com/api/useHref\n */\n\nfunction useHref(to) {\n  !useInRouterContext() ? process.env.NODE_ENV !== \"production\" ? invariant(false, // TODO: This error is probably because they somehow have 2 versions of the\n  // router loaded. We can help them understand how to avoid that.\n  \"useHref() may be used only in the context of a <Router> component.\") : invariant(false) : void 0;\n  var navigator = useContext(NavigatorContext);\n  var path = useResolvedPath(to);\n  return navigator.createHref(path);\n}\n/**\n * Returns true if this component is a descendant of a <Router>.\n *\n * @see https://reactrouter.com/api/useInRouterContext\n */\n\nfunction useInRouterContext() {\n  return useContext(LocationContext).location != null;\n}\n/**\n * Returns the current location object, which represents the current URL in web\n * browsers.\n *\n * Note: If you're using this it may mean you're doing some of your own\n * \"routing\" in your app, and we'd like to know what your use case is. We may\n * be able to provide something higher-level to better suit your needs.\n *\n * @see https://reactrouter.com/api/useLocation\n */\n\nfunction useLocation() {\n  !useInRouterContext() ? process.env.NODE_ENV !== \"production\" ? invariant(false, // TODO: This error is probably because they somehow have 2 versions of the\n  // router loaded. We can help them understand how to avoid that.\n  \"useLocation() may be used only in the context of a <Router> component.\") : invariant(false) : void 0;\n  return useContext(LocationContext).location;\n}\n/**\n * Returns true if the URL for the given \"to\" value matches the current URL.\n * This is useful for components that need to know \"active\" state, e.g.\n * <NavLink>.\n *\n * @see https://reactrouter.com/api/useMatch\n */\n\nfunction useMatch(pattern) {\n  !useInRouterContext() ? process.env.NODE_ENV !== \"production\" ? invariant(false, // TODO: This error is probably because they somehow have 2 versions of the\n  // router loaded. We can help them understand how to avoid that.\n  \"useMatch() may be used only in the context of a <Router> component.\") : invariant(false) : void 0;\n  var location = useLocation();\n  return matchPath(pattern, location.pathname);\n}\n/**\n * Returns an imperative method for changing the location. Used by <Link>s, but\n * may also be used by other elements to change the location.\n *\n * @see https://reactrouter.com/api/useNavigate\n */\n\nfunction useNavigate() {\n  !useInRouterContext() ? process.env.NODE_ENV !== \"production\" ? invariant(false, // TODO: This error is probably because they somehow have 2 versions of the\n  // router loaded. We can help them understand how to avoid that.\n  \"useNavigate() may be used only in the context of a <Router> component.\") : invariant(false) : void 0;\n  var navigator = useContext(NavigatorContext);\n\n  var _React$useContext = useContext(RouteContext),\n      pathname = _React$useContext.pathname,\n      basename = _React$useContext.basename;\n\n  var activeRef = useRef(false);\n  useEffect(function () {\n    activeRef.current = true;\n  });\n  var navigate = useCallback(function (to, options) {\n    if (options === void 0) {\n      options = {};\n    }\n\n    if (activeRef.current) {\n      if (typeof to === \"number\") {\n        navigator.go(to);\n      } else {\n        var path = resolvePath(to, pathname, basename);\n        (!!options.replace ? navigator.replace : navigator.push)(path, options.state);\n      }\n    } else {\n      process.env.NODE_ENV !== \"production\" ? warning(false, \"You should call navigate() in a useEffect, not when \" + \"your component is first rendered.\") : void 0;\n    }\n  }, [basename, navigator, pathname]);\n  return navigate;\n}\n/**\n * Returns the element for the child route at this level of the route\n * hierarchy. Used internally by <Outlet> to render child routes.\n *\n * @see https://reactrouter.com/api/useOutlet\n */\n\nfunction useOutlet() {\n  return useContext(RouteContext).outlet;\n}\n/**\n * Returns an object of key/value pairs of the dynamic params from the current\n * URL that were matched by the route path.\n *\n * @see https://reactrouter.com/api/useParams\n */\n\nfunction useParams() {\n  return useContext(RouteContext).params;\n}\n/**\n * Resolves the pathname of the given `to` value against the current location.\n *\n * @see https://reactrouter.com/api/useResolvedPath\n */\n\nfunction useResolvedPath(to) {\n  var _React$useContext2 = useContext(RouteContext),\n      pathname = _React$useContext2.pathname,\n      basename = _React$useContext2.basename;\n\n  return useMemo(function () {\n    return resolvePath(to, pathname, basename);\n  }, [to, pathname, basename]);\n}\n/**\n * Returns the element of the route that matched the current location, prepared\n * with the correct context to render the remainder of the route tree. Route\n * elements in the tree must render an <Outlet> to render their child route's\n * element.\n *\n * @see https://reactrouter.com/api/useRoutes\n */\n\nfunction useRoutes(partialRoutes, basename) {\n  if (basename === void 0) {\n    basename = \"\";\n  }\n\n  !useInRouterContext() ? process.env.NODE_ENV !== \"production\" ? invariant(false, // TODO: This error is probably because they somehow have 2 versions of the\n  // router loaded. We can help them understand how to avoid that.\n  \"useRoutes() may be used only in the context of a <Router> component.\") : invariant(false) : void 0;\n  var location = useLocation();\n  var routes = useMemo(function () {\n    return createRoutesFromArray(partialRoutes);\n  }, [partialRoutes]);\n  return useRoutes_(routes, location, basename);\n}\n\nfunction useRoutes_(routes, location, basename) {\n  if (basename === void 0) {\n    basename = \"\";\n  }\n\n  var _React$useContext3 = useContext(RouteContext),\n      parentRoute = _React$useContext3.route,\n      parentPathname = _React$useContext3.pathname,\n      parentParams = _React$useContext3.params;\n\n  if (process.env.NODE_ENV !== \"production\") {\n    // You won't get a warning about 2 different <Routes> under a <Route>\n    // without a trailing *, but this is a best-effort warning anyway since we\n    // cannot even give the warning unless they land at the parent route.\n    var parentPath = parentRoute && parentRoute.path;\n    warningOnce(parentPathname, !parentRoute || parentRoute.path.endsWith(\"*\"), \"You rendered descendant <Routes> (or called `useRoutes`) at \" + (\"\\\"\" + parentPathname + \"\\\" (under <Route path=\\\"\" + parentPath + \"\\\">) but the \") + \"parent route path has no trailing \\\"*\\\". This means if you navigate \" + \"deeper, the parent won't match anymore and therefore the child \" + \"routes will never render.\\n\\n\" + (\"Please change the parent <Route path=\\\"\" + parentPath + \"\\\"> to <Route \") + (\"path=\\\"\" + parentPath + \"/*\\\">.\"));\n  }\n\n  var basenameForMatching = basename ? joinPaths([parentPathname, basename]) : parentPathname;\n  var matches = useMemo(function () {\n    return matchRoutes(routes, location, basenameForMatching);\n  }, [location, routes, basenameForMatching]);\n\n  if (!matches) {\n    // TODO: Warn about nothing matching, suggest using a catch-all route.\n    return null;\n  } // Otherwise render an element.\n\n\n  var allParams = {};\n  var element = matches.reduceRight(function (outlet, _ref6) {\n    var params = _ref6.params,\n        pathname = _ref6.pathname,\n        route = _ref6.route;\n    allParams = _extends({}, allParams, params);\n    return /*#__PURE__*/createElement(RouteContext.Provider, {\n      children: route.element,\n      value: {\n        outlet: outlet,\n        params: readOnly(_extends({}, parentParams, allParams)),\n        pathname: joinPaths([basenameForMatching, pathname]),\n        basename: basename,\n        route: route\n      }\n    });\n  }, null);\n  return element;\n} ///////////////////////////////////////////////////////////////////////////////\n// UTILS\n///////////////////////////////////////////////////////////////////////////////\n\n/**\n * Creates a route config from an array of JavaScript objects. Used internally\n * by `useRoutes` to normalize the route config.\n *\n * @see https://reactrouter.com/api/createRoutesFromArray\n */\n\n\nfunction createRoutesFromArray(array) {\n  return array.map(function (partialRoute) {\n    var route = {\n      path: partialRoute.path || \"/\",\n      caseSensitive: partialRoute.caseSensitive === true,\n      element: partialRoute.element || /*#__PURE__*/createElement(Outlet, null)\n    };\n\n    if (partialRoute.children) {\n      route.children = createRoutesFromArray(partialRoute.children);\n    }\n\n    return route;\n  });\n}\n/**\n * Creates a route config from a React \"children\" object, which is usually\n * either a `<Route>` element or an array of them. Used internally by\n * `<Routes>` to create a route config from its children.\n *\n * @see https://reactrouter.com/api/createRoutesFromChildren\n */\n\nfunction createRoutesFromChildren(children) {\n  var routes = [];\n  Children.forEach(children, function (element) {\n    if (! /*#__PURE__*/isValidElement(element)) {\n      // Ignore non-elements. This allows people to more easily inline\n      // conditionals in their route config.\n      return;\n    }\n\n    if (element.type === Fragment) {\n      // Transparently support React.Fragment and its children.\n      routes.push.apply(routes, createRoutesFromChildren(element.props.children));\n      return;\n    }\n\n    var route = {\n      path: element.props.path || \"/\",\n      caseSensitive: element.props.caseSensitive === true,\n      // Default behavior is to just render the element that was given. This\n      // permits people to use any element they prefer, not just <Route> (though\n      // all our official examples and docs use <Route> for clarity).\n      element: element\n    };\n\n    if (element.props.children) {\n      var childRoutes = createRoutesFromChildren(element.props.children);\n\n      if (childRoutes.length) {\n        route.children = childRoutes;\n      }\n    }\n\n    routes.push(route);\n  });\n  return routes;\n}\n/**\n * Returns a path with params interpolated.\n *\n * @see https://reactrouter.com/api/generatePath\n */\n\nfunction generatePath(path, params) {\n  if (params === void 0) {\n    params = {};\n  }\n\n  return path.replace(/:(\\w+)/g, function (_, key) {\n    !(params[key] != null) ? process.env.NODE_ENV !== \"production\" ? invariant(false, \"Missing \\\":\" + key + \"\\\" param\") : invariant(false) : void 0;\n    return params[key];\n  }).replace(/\\/*\\*$/, function (_) {\n    return params[\"*\"] == null ? \"\" : params[\"*\"].replace(/^\\/*/, \"/\");\n  });\n}\n/**\n * Matches the given routes to a location and returns the match data.\n *\n * @see https://reactrouter.com/api/matchRoutes\n */\n\nfunction matchRoutes(routes, location, basename) {\n  if (basename === void 0) {\n    basename = \"\";\n  }\n\n  if (typeof location === \"string\") {\n    location = parsePath(location);\n  }\n\n  var pathname = location.pathname || \"/\";\n\n  if (basename) {\n    var base = basename.replace(/^\\/*/, \"/\").replace(/\\/+$/, \"\");\n\n    if (pathname.startsWith(base)) {\n      pathname = pathname === base ? \"/\" : pathname.slice(base.length);\n    } else {\n      // Pathname does not start with the basename, no match.\n      return null;\n    }\n  }\n\n  var branches = flattenRoutes(routes);\n  rankRouteBranches(branches);\n  var matches = null;\n\n  for (var i = 0; matches == null && i < branches.length; ++i) {\n    // TODO: Match on search, state too?\n    matches = matchRouteBranch(branches[i], pathname);\n  }\n\n  return matches;\n}\n\nfunction flattenRoutes(routes, branches, parentPath, parentRoutes, parentIndexes) {\n  if (branches === void 0) {\n    branches = [];\n  }\n\n  if (parentPath === void 0) {\n    parentPath = \"\";\n  }\n\n  if (parentRoutes === void 0) {\n    parentRoutes = [];\n  }\n\n  if (parentIndexes === void 0) {\n    parentIndexes = [];\n  }\n\n  routes.forEach(function (route, index) {\n    route = _extends({}, route, {\n      path: route.path || \"/\",\n      caseSensitive: !!route.caseSensitive,\n      element: route.element\n    });\n    var path = joinPaths([parentPath, route.path]);\n    var routes = parentRoutes.concat(route);\n    var indexes = parentIndexes.concat(index); // Add the children before adding this route to the array so we traverse the\n    // route tree depth-first and child routes appear before their parents in\n    // the \"flattened\" version.\n\n    if (route.children) {\n      flattenRoutes(route.children, branches, path, routes, indexes);\n    }\n\n    branches.push([path, routes, indexes]);\n  });\n  return branches;\n}\n\nfunction rankRouteBranches(branches) {\n  var pathScores = branches.reduce(function (memo, _ref7) {\n    var path = _ref7[0];\n    memo[path] = computeScore(path);\n    return memo;\n  }, {}); // Sorting is stable in modern browsers, but we still support IE 11, so we\n  // need this little helper.\n\n  stableSort(branches, function (a, b) {\n    var aPath = a[0],\n        aIndexes = a[2];\n    var aScore = pathScores[aPath];\n    var bPath = b[0],\n        bIndexes = b[2];\n    var bScore = pathScores[bPath];\n    return aScore !== bScore ? bScore - aScore // Higher score first\n    : compareIndexes(aIndexes, bIndexes);\n  });\n}\n\nvar paramRe = /^:\\w+$/;\nvar dynamicSegmentValue = 2;\nvar emptySegmentValue = 1;\nvar staticSegmentValue = 10;\nvar splatPenalty = -2;\n\nvar isSplat = function isSplat(s) {\n  return s === \"*\";\n};\n\nfunction computeScore(path) {\n  var segments = path.split(\"/\");\n  var initialScore = segments.length;\n\n  if (segments.some(isSplat)) {\n    initialScore += splatPenalty;\n  }\n\n  return segments.filter(function (s) {\n    return !isSplat(s);\n  }).reduce(function (score, segment) {\n    return score + (paramRe.test(segment) ? dynamicSegmentValue : segment === \"\" ? emptySegmentValue : staticSegmentValue);\n  }, initialScore);\n}\n\nfunction compareIndexes(a, b) {\n  var siblings = a.length === b.length && a.slice(0, -1).every(function (n, i) {\n    return n === b[i];\n  });\n  return siblings ? // If two routes are siblings, we should try to match the earlier sibling\n  // first. This allows people to have fine-grained control over the matching\n  // behavior by simply putting routes with identical paths in the order they\n  // want them tried.\n  a[a.length - 1] - b[b.length - 1] : // Otherwise, it doesn't really make sense to rank non-siblings by index,\n  // so they sort equally.\n  0;\n}\n\nfunction stableSort(array, compareItems) {\n  // This copy lets us get the original index of an item so we can preserve the\n  // original ordering in the case that they sort equally.\n  var copy = array.slice(0);\n  array.sort(function (a, b) {\n    return compareItems(a, b) || copy.indexOf(a) - copy.indexOf(b);\n  });\n}\n\nfunction matchRouteBranch(branch, pathname) {\n  var routes = branch[1];\n  var matchedPathname = \"/\";\n  var matchedParams = {};\n  var matches = [];\n\n  for (var i = 0; i < routes.length; ++i) {\n    var route = routes[i];\n    var remainingPathname = matchedPathname === \"/\" ? pathname : pathname.slice(matchedPathname.length) || \"/\";\n    var routeMatch = matchPath({\n      path: route.path,\n      caseSensitive: route.caseSensitive,\n      end: i === routes.length - 1\n    }, remainingPathname);\n    if (!routeMatch) return null;\n    matchedPathname = joinPaths([matchedPathname, routeMatch.pathname]);\n    matchedParams = _extends({}, matchedParams, routeMatch.params);\n    matches.push({\n      route: route,\n      pathname: matchedPathname,\n      params: readOnly(matchedParams)\n    });\n  }\n\n  return matches;\n}\n/**\n * Performs pattern matching on a URL pathname and returns information about\n * the match.\n *\n * @see https://reactrouter.com/api/matchPath\n */\n\n\nfunction matchPath(pattern, pathname) {\n  if (typeof pattern === \"string\") {\n    pattern = {\n      path: pattern\n    };\n  }\n\n  var _pattern = pattern,\n      path = _pattern.path,\n      _pattern$caseSensitiv = _pattern.caseSensitive,\n      caseSensitive = _pattern$caseSensitiv === void 0 ? false : _pattern$caseSensitiv,\n      _pattern$end = _pattern.end,\n      end = _pattern$end === void 0 ? true : _pattern$end;\n\n  var _compilePath = compilePath(path, caseSensitive, end),\n      matcher = _compilePath[0],\n      paramNames = _compilePath[1];\n\n  var match = pathname.match(matcher);\n  if (!match) return null;\n  var matchedPathname = match[1];\n  var values = match.slice(2);\n  var params = paramNames.reduce(function (memo, paramName, index) {\n    memo[paramName] = safelyDecodeURIComponent(values[index] || \"\", paramName);\n    return memo;\n  }, {});\n  return {\n    path: path,\n    pathname: matchedPathname,\n    params: params\n  };\n}\n\nfunction compilePath(path, caseSensitive, end) {\n  var keys = [];\n  var source = \"^(\" + path.replace(/^\\/*/, \"/\") // Make sure it has a leading /\n  .replace(/\\/?\\*?$/, \"\") // Ignore trailing / and /*, we'll handle it below\n  .replace(/[\\\\.*+^$?{}|()[\\]]/g, \"\\\\$&\") // Escape special regex chars\n  .replace(/:(\\w+)/g, function (_, key) {\n    keys.push(key);\n    return \"([^\\\\/]+)\";\n  }) + \")\";\n\n  if (path.endsWith(\"*\")) {\n    if (path.endsWith(\"/*\")) {\n      source += \"(?:\\\\/(.+)|\\\\/?)\"; // Don't include the / in params['*']\n    } else {\n      source += \"(.*)\";\n    }\n\n    keys.push(\"*\");\n  } else if (end) {\n    source += \"\\\\/?\";\n  }\n\n  if (end) source += \"$\";\n  var flags = caseSensitive ? undefined : \"i\";\n  var matcher = new RegExp(source, flags);\n  return [matcher, keys];\n}\n\nfunction safelyDecodeURIComponent(value, paramName) {\n  try {\n    return decodeURIComponent(value);\n  } catch (error) {\n    process.env.NODE_ENV !== \"production\" ? warning(false, \"The value for the URL param \\\"\" + paramName + \"\\\" will not be decoded because\" + (\" the string \\\"\" + value + \"\\\" is a malformed URL segment. This is probably\") + (\" due to a bad percent encoding (\" + error + \").\")) : void 0;\n    return value;\n  }\n}\n/**\n * Returns a resolved path object relative to the given pathname.\n *\n * @see https://reactrouter.com/api/resolvePath\n */\n\n\nfunction resolvePath(to, fromPathname, basename) {\n  if (fromPathname === void 0) {\n    fromPathname = \"/\";\n  }\n\n  if (basename === void 0) {\n    basename = \"\";\n  }\n\n  var _ref8 = typeof to === \"string\" ? parsePath(to) : to,\n      toPathname = _ref8.pathname,\n      _ref8$search = _ref8.search,\n      search = _ref8$search === void 0 ? \"\" : _ref8$search,\n      _ref8$hash = _ref8.hash,\n      hash = _ref8$hash === void 0 ? \"\" : _ref8$hash;\n\n  var pathname = toPathname ? resolvePathname(toPathname, toPathname.startsWith(\"/\") ? basename ? normalizeSlashes(\"/\" + basename) : \"/\" : fromPathname) : fromPathname;\n  return {\n    pathname: pathname,\n    search: normalizeSearch(search),\n    hash: normalizeHash(hash)\n  };\n}\n\nvar trimTrailingSlashes = function trimTrailingSlashes(path) {\n  return path.replace(/\\/+$/, \"\");\n};\n\nvar normalizeSlashes = function normalizeSlashes(path) {\n  return path.replace(/\\/\\/+/g, \"/\");\n};\n\nvar joinPaths = function joinPaths(paths) {\n  return normalizeSlashes(paths.join(\"/\"));\n};\n\nvar splitPath = function splitPath(path) {\n  return normalizeSlashes(path).split(\"/\");\n};\n\nvar normalizeSearch = function normalizeSearch(search) {\n  return !search || search === \"?\" ? \"\" : search.startsWith(\"?\") ? search : \"?\" + search;\n};\n\nvar normalizeHash = function normalizeHash(hash) {\n  return !hash || hash === \"#\" ? \"\" : hash.startsWith(\"#\") ? hash : \"#\" + hash;\n};\n\nfunction resolvePathname(toPathname, fromPathname) {\n  var segments = splitPath(trimTrailingSlashes(fromPathname));\n  var relativeSegments = splitPath(toPathname);\n  relativeSegments.forEach(function (segment) {\n    if (segment === \"..\") {\n      // Keep the root \"\" segment so the pathname starts at /\n      if (segments.length > 1) segments.pop();\n    } else if (segment !== \".\") {\n      segments.push(segment);\n    }\n  });\n  return segments.length > 1 ? joinPaths(segments) : \"/\";\n} ///////////////////////////////////////////////////////////////////////////////\n\nexport { MemoryRouter, Navigate, Outlet, Route, Router, Routes, LocationContext as UNSAFE_LocationContext, NavigatorContext as UNSAFE_NavigatorContext, RouteContext as UNSAFE_RouteContext, createRoutesFromArray, createRoutesFromChildren, generatePath, matchPath, matchRoutes, resolvePath, useBlocker, useHref, useInRouterContext, useLocation, useMatch, useNavigate, useOutlet, useParams, useResolvedPath, useRoutes };\n//# sourceMappingURL=index.js.map\n"]},"metadata":{},"sourceType":"module"}